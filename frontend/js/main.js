const joinScreen = document.getElementById('join-screen');
const conferenceScreen = document.getElementById('conference-screen');
const joinBtn = document.getElementById('join-btn');
const roomIdInput = document.getElementById('room-id');
const usernameInput = document.getElementById('username');
const roomTitle = document.getElementById('room-title');
const localVideo = document.getElementById('local-video');
const videoGrid = document.getElementById('video-grid');

// Controls
const toggleAudioBtn = document.getElementById('toggle-audio-btn');
const toggleVideoBtn = document.getElementById('toggle-video-btn');
const shareScreenBtn = document.getElementById('share-screen-btn');
const leaveBtn = document.getElementById('leave-btn');

// Chat
const chatBox = document.getElementById('chat-box');
const chatInput = document.getElementById('chat-message');
const sendChatBtn = document.getElementById('send-chat-btn');

let localStream;
let screenStream;
let ws;
let roomId;
let clientId;
let username;

// Peer Connections: peerId -> RTCPeerConnection
const peerConnections = {};

// ICE Servers (Google's public STUN server for NAT traversal)
// In production, add a TURN server here (e.g., Coturn)
const rtcConfig = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
    ]
};

// Generate a random ID
function generateId() {
    return Math.random().toString(36).substring(2, 15);
}

joinBtn.addEventListener('click', async () => {
    roomId = roomIdInput.value.trim();
    username = usernameInput.value.trim();
    if (!roomId || !username) {
        alert("Please enter both Room ID and Username.");
        return;
    }

    clientId = generateId();
    roomTitle.innerText = `Room: ${roomId}`;

    try {
        // Get local media
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
        
        // Switch UI
        joinScreen.classList.add('hidden');
        conferenceScreen.classList.remove('hidden');

        // Connect WebSocket
        connectWebSocket();
    } catch (err) {
        console.error("Error accessing media devices.", err);
        alert("Could not access camera/microphone.");
    }
});

function connectWebSocket() {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const host = window.location.hostname;
    const port = window.location.port ? `:${window.location.port}` : '';
    
    // Safety: Encode components to prevent URL breakages
    const encodedRoom = encodeURIComponent(roomId);
    const encodedClient = encodeURIComponent(clientId);
    
    const wsUrl = `${protocol}//${host}${port}/ws/${encodedRoom}/${encodedClient}`;
    
    console.log(`[WS] Attempting connection: ${wsUrl}`);
    
    if (ws) {
        ws.close();
    }

    ws = new WebSocket(wsUrl);

    ws.onopen = () => {
        console.log("[WS] Connection successful!");
    };

    ws.onclose = (event) => {
        console.warn(`[WS] Disconnected. Code: ${event.code}, Reason: ${event.reason}`);
        // Only show alert if it wasn't a manual leave
        if (event.code !== 1000) {
            alert("Connection lost. Please check if the server is running.");
            leaveRoom();
        }
    };

    ws.onerror = (error) => {
        console.error("[WS] Error observed:", error);
    };

    ws.onmessage = async (event) => {
        const message = JSON.parse(event.data);
        const peerId = message.peerId;

        switch (message.type) {
            case 'new-peer':
                console.log("New peer joined:", peerId);
                // Create an offer to the new peer
                await createPeerConnection(peerId, true);
                break;
            case 'offer':
                console.log("Received offer from:", peerId);
                await handleOffer(message, peerId);
                break;
            case 'answer':
                console.log("Received answer from:", peerId);
                await handleAnswer(message, peerId);
                break;
            case 'ice-candidate':
                await handleIceCandidate(message, peerId);
                break;
            case 'peer-left':
                console.log("Peer left:", peerId);
                removePeer(peerId);
                break;
            case 'chat':
                appendChatMessage(message.username, message.text, false);
                break;
        }
    };

    ws.onclose = () => {
        console.log("WebSocket disconnected.");
        leaveRoom();
    };
}

async function createPeerConnection(peerId, isInitiator) {
    const pc = new RTCPeerConnection(rtcConfig);
    peerConnections[peerId] = pc;

    // Add local tracks to connection
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

    // Handle ICE candidates generated by the local WebRTC stack
    pc.onicecandidate = (event) => {
        if (event.candidate) {
            ws.send(JSON.stringify({
                type: 'ice-candidate',
                targetPeer: peerId,
                candidate: event.candidate
            }));
        }
    };

    // Handle remote tracks received
    pc.ontrack = (event) => {
        const remoteStream = event.streams[0];
        addRemoteVideo(peerId, remoteStream);
    };

    // If we are the initiator, create and send an offer
    if (isInitiator) {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({
            type: 'offer',
            targetPeer: peerId,
            sdp: pc.localDescription
        }));
    }

    return pc;
}

async function handleOffer(message, peerId) {
    const pc = await createPeerConnection(peerId, false);
    await pc.setRemoteDescription(new RTCSessionDescription(message.sdp));
    
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    
    ws.send(JSON.stringify({
        type: 'answer',
        targetPeer: peerId,
        sdp: pc.localDescription
    }));
}

async function handleAnswer(message, peerId) {
    const pc = peerConnections[peerId];
    if (pc) {
        await pc.setRemoteDescription(new RTCSessionDescription(message.sdp));
    }
}

async function handleIceCandidate(message, peerId) {
    const pc = peerConnections[peerId];
    if (pc) {
        try {
            await pc.addIceCandidate(new RTCIceCandidate(message.candidate));
        } catch (e) {
            console.error('Error adding received ice candidate', e);
        }
    }
}

function addRemoteVideo(peerId, stream) {
    // Check if video element already exists
    if (document.getElementById(`video-container-${peerId}`)) return;

    const container = document.createElement('div');
    container.id = `video-container-${peerId}`;
    container.className = 'video-container';

    const video = document.createElement('video');
    video.id = `video-${peerId}`;
    video.autoplay = true;
    video.playsInline = true;
    video.srcObject = stream;

    const label = document.createElement('div');
    label.className = 'label';
    label.innerText = `Peer ${peerId.substring(0,4)}`; // Ideally map to username

    container.appendChild(video);
    container.appendChild(label);
    videoGrid.appendChild(container);
}

function removePeer(peerId) {
    if (peerConnections[peerId]) {
        peerConnections[peerId].close();
        delete peerConnections[peerId];
    }
    const container = document.getElementById(`video-container-${peerId}`);
    if (container) {
        container.remove();
    }
}

function leaveRoom() {
    // Close all peer connections
    for (let peerId in peerConnections) {
        removePeer(peerId);
    }
    // Stop local media
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
    }
    if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop());
    }
    // Close WebSocket
    if (ws) ws.close();

    // Reset UI
    conferenceScreen.classList.add('hidden');
    joinScreen.classList.remove('hidden');
    
    // Clear chat
    chatBox.innerHTML = '';
}

// Media Controls
toggleAudioBtn.addEventListener('click', () => {
    const audioTrack = localStream.getAudioTracks()[0];
    if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        toggleAudioBtn.innerText = audioTrack.enabled ? "Unmute Audio" : "Mute Audio";
        toggleAudioBtn.classList.toggle('danger', !audioTrack.enabled);
    }
});

toggleVideoBtn.addEventListener('click', () => {
    const videoTrack = localStream.getVideoTracks()[0];
    if (videoTrack) {
        videoTrack.enabled = !videoTrack.enabled;
        toggleVideoBtn.innerText = videoTrack.enabled ? "Turn On Camera" : "Turn Off Camera";
        toggleVideoBtn.classList.toggle('danger', !videoTrack.enabled);
    }
});

shareScreenBtn.addEventListener('click', async () => {
    try {
        if (!screenStream) {
            screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
            const screenTrack = screenStream.getVideoTracks()[0];
            
            // Replace track in all peer connections
            for (let peerId in peerConnections) {
                const pc = peerConnections[peerId];
                const sender = pc.getSenders().find(s => s.track.kind === 'video');
                if (sender) {
                    sender.replaceTrack(screenTrack);
                }
            }
            
            // Show locally
            localVideo.srcObject = screenStream;
            shareScreenBtn.innerText = "Stop Sharing";
            shareScreenBtn.classList.add('active');

            screenTrack.onended = stopScreenShare;
        } else {
            stopScreenShare();
        }
    } catch (err) {
        console.error("Error sharing screen:", err);
    }
});

function stopScreenShare() {
    if (screenStream) {
        screenStream.getTracks().forEach(track => track.stop());
        screenStream = null;
        
        const videoTrack = localStream.getVideoTracks()[0];
        
        // Restore local camera in peer connections
        for (let peerId in peerConnections) {
            const pc = peerConnections[peerId];
            const sender = pc.getSenders().find(s => s.track.kind === 'video');
            if (sender) {
                sender.replaceTrack(videoTrack);
            }
        }
        
        // Restore locally
        localVideo.srcObject = localStream;
        shareScreenBtn.innerText = "Share Screen";
        shareScreenBtn.classList.remove('active');
    }
}

leaveBtn.addEventListener('click', leaveRoom);

// Chat messaging
sendChatBtn.addEventListener('click', sendChatMessage);
chatInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') sendChatMessage();
});

function sendChatMessage() {
    const text = chatInput.value.trim();
    if (text && ws && ws.readyState === WebSocket.OPEN) {
        const msg = {
            type: 'chat',
            username: username,
            text: text
        };
        ws.send(JSON.stringify(msg));
        appendChatMessage("You", text, true);
        chatInput.value = '';
    }
}

function appendChatMessage(user, text, isSelf) {
    const div = document.createElement('div');
    div.className = `chat-message ${isSelf ? 'self' : ''}`;
    div.innerText = `${user}: ${text}`;
    chatBox.appendChild(div);
    chatBox.scrollTop = chatBox.scrollHeight;
}